{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\nvar mountCounters = new WeakMap();\nvar callbackMap = new WeakMap();\n\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\nfunction setCallbackMap(context) {\n  var callbacks = callbackMap.get(context);\n\n  if (callbacks) {\n    return callbacks;\n  }\n\n  var onMouseDown = function (ev) {\n    return _onMouseDown(ev, context.registeredProviders);\n  };\n\n  var onPointerDown = function (ev) {\n    return _onPointerDown(ev, context.registeredProviders);\n  };\n\n  var onKeyDown = function (ev) {\n    return _onKeyDown(ev, context.registeredProviders);\n  };\n\n  var onKeyUp = function (ev) {\n    return _onKeyUp(ev, context.registeredProviders);\n  };\n\n  callbacks = {\n    onMouseDown: onMouseDown,\n    onPointerDown: onPointerDown,\n    onKeyDown: onKeyDown,\n    onKeyUp: onKeyUp\n  };\n  callbackMap.set(context, callbacks);\n  return callbacks;\n}\n\nexport var FocusRectsContext = React.createContext(undefined);\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of\n *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to\n *    call this method multiple times.)\n * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the\n *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document\n *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via\n *    context, and removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\n\nexport function useFocusRects(rootRef) {\n  var context = React.useContext(FocusRectsContext);\n  React.useEffect(function () {\n    var _a, _b;\n\n    var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);\n\n    if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n      return undefined;\n    }\n\n    var el = win;\n    var onMouseDown;\n    var onPointerDown;\n    var onKeyDown;\n    var onKeyUp;\n\n    if ((_b = context === null || context === void 0 ? void 0 : context.providerRef) === null || _b === void 0 ? void 0 : _b.current) {\n      el = context.providerRef.current;\n      var callbacks = setCallbackMap(context);\n      onMouseDown = callbacks.onMouseDown;\n      onPointerDown = callbacks.onPointerDown;\n      onKeyDown = callbacks.onKeyDown;\n      onKeyUp = callbacks.onKeyUp;\n    } else {\n      onMouseDown = _onMouseDown;\n      onPointerDown = _onPointerDown;\n      onKeyDown = _onKeyDown;\n      onKeyUp = _onKeyUp;\n    }\n\n    var count = setMountCounters(el, 1);\n\n    if (count <= 1) {\n      el.addEventListener('mousedown', onMouseDown, true);\n      el.addEventListener('pointerdown', onPointerDown, true);\n      el.addEventListener('keydown', onKeyDown, true);\n      el.addEventListener('keyup', onKeyUp, true);\n    }\n\n    return function () {\n      var _a;\n\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n\n      count = setMountCounters(el, -1);\n\n      if (count === 0) {\n        el.removeEventListener('mousedown', onMouseDown, true);\n        el.removeEventListener('pointerdown', onPointerDown, true);\n        el.removeEventListener('keydown', onKeyDown, true);\n        el.removeEventListener('keyup', onKeyUp, true);\n      }\n    };\n  }, [context, rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\n\nexport var FocusRects = function (props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev, registeredProviders) {\n  setFocusVisibility(false, ev.target, registeredProviders);\n}\n\nfunction _onPointerDown(ev, registeredProviders) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target, registeredProviders);\n  }\n} // You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when\n// attaching the listeners and classnames to the provider instead of the document body.\n// If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider\n// to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.\n// If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements\n// if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for\n// every element that is being tabbed into.\n// This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList\n// when focus visibility is turned on.\n\n\nfunction _onKeyDown(ev, registeredProviders) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target, registeredProviders);\n  }\n}\n\nfunction _onKeyUp(ev, registeredProviders) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target, registeredProviders);\n  }\n}","map":{"version":3,"mappings":"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","names":["React","getWindow","isDirectionalKeyCode","setFocusVisibility","mountCounters","WeakMap","callbackMap","setMountCounters","key","delta","newValue","currValue","get","set","setCallbackMap","context","callbacks","onMouseDown","ev","registeredProviders","onPointerDown","onKeyDown","onKeyUp","FocusRectsContext","createContext","undefined","useFocusRects","rootRef","useContext","useEffect","win","current","FabricConfig","_a","disableFocusRects","el","providerRef","_b","_onMouseDown","_onPointerDown","_onKeyDown","_onKeyUp","count","addEventListener","removeEventListener","FocusRects","props","target","pointerType","which"],"sources":["/Users/aalyanmahmood/Documents/GitHub/OffCampus-Mac/node_modules/@fluentui/utilities/src/useFocusRects.ts"],"sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangles.\n * We want to cleanup the listeners before the last component that uses focus rectangles unmounts.\n */\nexport type ListenerCallbacks = {\n  onMouseDown: (ev: MouseEvent) => void;\n  onPointerDown: (ev: PointerEvent) => void;\n  onKeyDown: (ev: KeyboardEvent) => void;\n  onKeyUp: (ev: KeyboardEvent) => void;\n};\nlet mountCounters = new WeakMap<Window | HTMLElement, number>();\nlet callbackMap = new WeakMap<IFocusRectsContext, ListenerCallbacks>();\n\nfunction setMountCounters(key: Window | HTMLElement, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\nfunction setCallbackMap(context: IFocusRectsContext): ListenerCallbacks {\n  let callbacks = callbackMap.get(context);\n  if (callbacks) {\n    return callbacks;\n  }\n\n  const onMouseDown = (ev: MouseEvent) => _onMouseDown(ev, context.registeredProviders);\n  const onPointerDown = (ev: PointerEvent) => _onPointerDown(ev, context.registeredProviders);\n  const onKeyDown = (ev: KeyboardEvent) => _onKeyDown(ev, context.registeredProviders);\n  const onKeyUp = (ev: KeyboardEvent) => _onKeyUp(ev, context.registeredProviders);\n  callbacks = { onMouseDown, onPointerDown, onKeyDown, onKeyUp };\n\n  callbackMap.set(context, callbacks);\n  return callbacks;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\nexport type IFocusRectsContext = {\n  /**\n   * Ref to the root element of the provider\n   */\n  readonly providerRef: React.RefObject<HTMLElement>;\n\n  /**\n   * Array of this and all child provider elements under this one in the React tree.\n   *\n   * Tracking all child providers will allow a focus event in the parent to also set focus styling in its descendants.\n   * This is needed for Combobox, for example, because the focus events happen on the parent context, but the visual\n   * focus indicator is in the combobox callout. The callout needs to be notified on focus events from the parent.\n   */\n  readonly registeredProviders: React.RefObject<HTMLElement>[];\n\n  /**\n   * Used by child FocusRectsProviders to register their element with the parent provider.\n   */\n  readonly registerProvider: (ref: React.RefObject<HTMLElement>) => void;\n\n  /**\n   * Used by child FocusRectsProviders to unregister their element from the parent provider.\n   */\n  readonly unregisterProvider: (ref: React.RefObject<HTMLElement>) => void;\n};\n\nexport const FocusRectsContext = React.createContext<IFocusRectsContext | undefined>(undefined);\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of\n *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to\n *    call this method multiple times.)\n * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the\n *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document\n *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via\n *    context, and removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  const context = React.useContext(FocusRectsContext);\n\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let el: Window | HTMLElement = win;\n    let onMouseDown: (ev: MouseEvent) => void;\n    let onPointerDown: (ev: PointerEvent) => void;\n    let onKeyDown: (ev: KeyboardEvent) => void;\n    let onKeyUp: (ev: KeyboardEvent) => void;\n    if (context?.providerRef?.current) {\n      el = context.providerRef.current;\n      const callbacks = setCallbackMap(context);\n      onMouseDown = callbacks.onMouseDown;\n      onPointerDown = callbacks.onPointerDown;\n      onKeyDown = callbacks.onKeyDown;\n      onKeyUp = callbacks.onKeyUp;\n    } else {\n      onMouseDown = _onMouseDown;\n      onPointerDown = _onPointerDown;\n      onKeyDown = _onKeyDown;\n      onKeyUp = _onKeyUp;\n    }\n\n    let count = setMountCounters(el, 1);\n    if (count <= 1) {\n      el.addEventListener('mousedown', onMouseDown, true);\n      el.addEventListener('pointerdown', onPointerDown, true);\n      el.addEventListener('keydown', onKeyDown, true);\n      el.addEventListener('keyup', onKeyUp, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n      count = setMountCounters(el, -1);\n      if (count === 0) {\n        el.removeEventListener('mousedown', onMouseDown, true);\n        el.removeEventListener('pointerdown', onPointerDown, true);\n        el.removeEventListener('keydown', onKeyDown, true);\n        el.removeEventListener('keyup', onKeyUp, true);\n      }\n    };\n  }, [context, rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  setFocusVisibility(false, ev.target as Element, registeredProviders);\n}\n\nfunction _onPointerDown(ev: PointerEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element, registeredProviders);\n  }\n}\n\n// You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when\n// attaching the listeners and classnames to the provider instead of the document body.\n// If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider\n// to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.\n// If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements\n// if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for\n// every element that is being tabbed into.\n// This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList\n// when focus visibility is turned on.\nfunction _onKeyDown(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n\nfunction _onKeyUp(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}