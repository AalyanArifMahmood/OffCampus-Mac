{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, KeyCodes, elementContains, findScrollableParent, getParent, getDocument, getWindow, isElementTabbable, css, initializeComponentRef, FocusRects } from '../../Utilities';\nimport { SelectionMode } from './interfaces'; // Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nvar SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nvar SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nvar SELECTION_SPAN_ATTRIBUTE_NAME = 'data-selection-span';\nvar SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nvar SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nvar SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nvar SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nvar SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n/**\n * {@docCategory Selection}\n */\n\nvar SelectionZone =\n/** @class */\nfunction (_super) {\n  __extends(SelectionZone, _super);\n\n  function SelectionZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    /**\n     * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n     * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n     * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n     * focus event that occurs. This method does that.\n     */\n\n    _this.ignoreNextFocus = function () {\n      _this._handleNextFocus(false);\n    };\n\n    _this._onSelectionChange = function () {\n      var selection = _this.props.selection;\n      var isModal = selection.isModal && selection.isModal();\n\n      _this.setState({\n        isModal: isModal\n      });\n    };\n\n    _this._onMouseDownCapture = function (ev) {\n      var target = ev.target;\n\n      if (document.activeElement !== target && !elementContains(document.activeElement, target)) {\n        _this.ignoreNextFocus();\n\n        return;\n      }\n\n      if (!elementContains(target, _this._root.current)) {\n        return;\n      }\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          _this.ignoreNextFocus();\n\n          break;\n        }\n\n        target = getParent(target);\n      }\n    };\n    /**\n     * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n     * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n     * specially.\n     */\n\n\n    _this._onFocus = function (ev) {\n      var target = ev.target;\n      var selection = _this.props.selection;\n      var isToggleModifierPressed = _this._isCtrlPressed || _this._isMetaPressed;\n\n      var selectionMode = _this._getSelectionMode();\n\n      if (_this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n        var isToggle = _this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n\n        var itemRoot = _this._findItemRoot(target);\n\n        if (!isToggle && itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          var span = _this._getItemSpan(itemRoot);\n\n          if (span === undefined) {\n            if (isToggleModifierPressed) {\n              // set anchor only.\n              selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n\n              if (_this.props.enterModalOnTouch && _this._isTouch && selection.setModal) {\n                selection.setModal(true);\n\n                _this._setIsTouch(false);\n              }\n            } else {\n              if (_this.props.isSelectedOnFocus) {\n                _this._onItemSurfaceClick('focus', index);\n              }\n            }\n          }\n        }\n      }\n\n      _this._handleNextFocus(false);\n    };\n\n    _this._onMouseDown = function (ev) {\n      _this._updateModifiers(ev);\n\n      var toggleWithoutModifierPressed = _this.props.toggleWithoutModifierPressed;\n      var target = ev.target;\n\n      var itemRoot = _this._findItemRoot(target); // No-op if selection is disabled\n\n\n      if (_this._isSelectionDisabled(target)) {\n        return;\n      }\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          break;\n        } else if (itemRoot) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if ((target === itemRoot || _this._shouldAutoSelect(target)) && !_this._isShiftPressed && !_this._isCtrlPressed && !_this._isMetaPressed && !toggleWithoutModifierPressed) {\n            _this._onInvokeMouseDown(ev, _this._getItemIndex(itemRoot), _this._getItemSpan(itemRoot));\n\n            break;\n          } else if (_this.props.disableAutoSelectOnInputElements && (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')) {\n            return;\n          }\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onTouchStartCapture = function (ev) {\n      _this._setIsTouch(true);\n    };\n\n    _this._onClick = function (ev) {\n      var _a = _this.props.enableTouchInvocationTarget,\n          enableTouchInvocationTarget = _a === void 0 ? false : _a;\n\n      _this._updateModifiers(ev);\n\n      var target = ev.target;\n\n      var itemRoot = _this._findItemRoot(target);\n\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            _this._onToggleAllClick(ev);\n          }\n\n          break;\n        } else if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          var span = _this._getItemSpan(itemRoot);\n\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            if (!isSelectionDisabled) {\n              if (_this._isShiftPressed) {\n                _this._onItemSurfaceClick('click', index, span);\n              } else {\n                _this._onToggleClick(ev, index, span);\n              }\n            }\n\n            break;\n          } else if (_this._isTouch && enableTouchInvocationTarget && _this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            if (span === undefined) {\n              // Items should be invokable even if selection is disabled.\n              _this._onInvokeClick(ev, index);\n            }\n\n            break;\n          } else if (target === itemRoot) {\n            if (!isSelectionDisabled) {\n              _this._onItemSurfaceClick('click', index, span);\n            }\n\n            break;\n          } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n            return;\n          }\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onContextMenu = function (ev) {\n      var target = ev.target;\n      var _a = _this.props,\n          onItemContextMenu = _a.onItemContextMenu,\n          selection = _a.selection;\n\n      if (onItemContextMenu) {\n        var itemRoot = _this._findItemRoot(target);\n\n        if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          _this._onInvokeMouseDown(ev, index);\n\n          var skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent); // In order to keep back compat, if the value here is undefined, then we should still\n          // call preventDefault(). Only in the case where true is explicitly returned should\n          // the call be skipped.\n\n          if (!skipPreventDefault) {\n            ev.preventDefault();\n          }\n        }\n      }\n    };\n    /**\n     * In multi selection, if you double click within an item's root (but not within the invoke element or\n     * input elements), we should execute the invoke handler.\n     */\n\n\n    _this._onDoubleClick = function (ev) {\n      var target = ev.target;\n      var onItemInvoked = _this.props.onItemInvoked;\n\n      var itemRoot = _this._findItemRoot(target);\n\n      if (itemRoot && onItemInvoked && !_this._isInputElement(target)) {\n        var index = _this._getItemIndex(itemRoot);\n\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (target === itemRoot) {\n            _this._onInvokeClick(ev, index);\n\n            break;\n          }\n\n          target = getParent(target);\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onKeyDownCapture = function (ev) {\n      _this._updateModifiers(ev);\n\n      _this._handleNextFocus(true);\n    };\n\n    _this._onKeyDown = function (ev) {\n      _this._updateModifiers(ev);\n\n      var target = ev.target;\n\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n\n      var _a = _this.props,\n          selection = _a.selection,\n          selectionClearedOnEscapePress = _a.selectionClearedOnEscapePress; // eslint-disable-next-line deprecation/deprecation\n\n      var isSelectAllKey = ev.which === KeyCodes.a && (_this._isCtrlPressed || _this._isMetaPressed); // eslint-disable-next-line deprecation/deprecation\n\n      var isClearSelectionKey = ev.which === KeyCodes.escape; // Ignore key downs from input elements.\n\n      if (_this._isInputElement(target)) {\n        // A key was pressed while an item in this zone was focused.\n        return;\n      }\n\n      var selectionMode = _this._getSelectionMode(); // If ctrl-a is pressed, select all (if all are not already selected.)\n\n\n      if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(true);\n        }\n\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      } // If escape is pressed and the component is configured to clear on escape press,\n      // clear selection (if any are selected.)\n\n\n      if (selectionClearedOnEscapePress && isClearSelectionKey && selection.getSelectedCount() > 0) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(false);\n        }\n\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      }\n\n      var itemRoot = _this._findItemRoot(target); // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n\n\n      if (itemRoot) {\n        var index = _this._getItemIndex(itemRoot);\n\n        var span = _this._getItemSpan(itemRoot);\n\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n            // so we can no-op for any keydowns in this case.\n            break;\n          } else if (_this._shouldAutoSelect(target)) {\n            if (!isSelectionDisabled && span === undefined) {\n              // If the event went to an element which should trigger auto-select, select it and then let\n              // the default behavior kick in.\n              _this._onInvokeMouseDown(ev, index, span);\n            }\n\n            break;\n          } else if ( // eslint-disable-next-line deprecation/deprecation\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) && (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT')) {\n            return false;\n          } else if (target === itemRoot) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (ev.which === KeyCodes.enter) {\n              if (span === undefined) {\n                // Items should be invokable even if selection is disabled.\n                _this._onInvokeClick(ev, index);\n\n                ev.preventDefault();\n              }\n\n              return; // eslint-disable-next-line deprecation/deprecation\n            } else if (ev.which === KeyCodes.space) {\n              if (!isSelectionDisabled) {\n                _this._onToggleClick(ev, index, span);\n              }\n\n              ev.preventDefault();\n              return;\n            }\n\n            break;\n          }\n\n          target = getParent(target);\n        }\n      }\n    };\n\n    _this._events = new EventGroup(_this);\n    _this._async = new Async(_this);\n    initializeComponentRef(_this);\n    var selection = _this.props.selection; // Reflect the initial modal state of selection into the state.\n\n    var isModal = selection.isModal && selection.isModal();\n    _this.state = {\n      isModal: isModal\n    };\n    return _this;\n  }\n\n  SelectionZone.getDerivedStateFromProps = function (nextProps, prevState) {\n    var isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n    return __assign(__assign({}, prevState), {\n      isModal: isModal\n    });\n  };\n\n  SelectionZone.prototype.componentDidMount = function () {\n    var win = getWindow(this._root.current); // Track the latest modifier keys globally.\n\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n\n    this._events.on(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n\n    this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);\n\n    this._events.on(document.body, 'touchend', this._onTouchStartCapture, true); // Subscribe to the selection to keep modal state updated.\n\n\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  };\n\n  SelectionZone.prototype.render = function () {\n    var isModal = this.state.isModal;\n    return React.createElement(\"div\", {\n      className: css('ms-SelectionZone', this.props.className, {\n        'ms-SelectionZone--modal': !!isModal\n      }),\n      ref: this._root,\n      onKeyDown: this._onKeyDown,\n      onMouseDown: this._onMouseDown,\n      onKeyDownCapture: this._onKeyDownCapture,\n      onClick: this._onClick,\n      role: \"presentation\",\n      onDoubleClick: this._onDoubleClick,\n      onContextMenu: this._onContextMenu,\n      onMouseDownCapture: this._onMouseDownCapture,\n      onFocusCapture: this._onFocus,\n      \"data-selection-is-modal\": isModal ? true : undefined\n    }, this.props.children, React.createElement(FocusRects, null));\n  };\n\n  SelectionZone.prototype.componentDidUpdate = function (previousProps) {\n    var selection = this.props.selection;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  };\n\n  SelectionZone.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  SelectionZone.prototype._isSelectionDisabled = function (target) {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n\n      target = getParent(target);\n    }\n\n    return false;\n  };\n\n  SelectionZone.prototype._onToggleAllClick = function (ev) {\n    var selection = this.props.selection;\n\n    var selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  };\n\n  SelectionZone.prototype._onToggleClick = function (ev, index, span) {\n    var selection = this.props.selection;\n\n    var selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (this.props.enterModalOnTouch && this._isTouch && (span !== undefined ? !selection.isRangeSelected(index, span) : !selection.isIndexSelected(index)) && selection.setModal) {\n      selection.setModal(true);\n\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (span !== undefined) {\n        selection.toggleRangeSelected(index, span);\n      } else {\n        selection.toggleIndexSelected(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      if (span === undefined || span === 1) {\n        var isSelected = selection.isIndexSelected(index);\n        var isModal = selection.isModal && selection.isModal();\n        selection.setAllSelected(false);\n        selection.setIndexSelected(index, !isSelected, true);\n\n        if (isModal && selection.setModal) {\n          // Since the above call to setAllSelected(false) clears modal state,\n          // restore it. This occurs because the SelectionMode of the Selection\n          // may differ from the SelectionZone.\n          selection.setModal(true);\n        }\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n    ev.stopPropagation(); // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  };\n\n  SelectionZone.prototype._onInvokeClick = function (ev, index) {\n    var _a = this.props,\n        selection = _a.selection,\n        onItemInvoked = _a.onItemInvoked;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  SelectionZone.prototype._onItemSurfaceClick = function (type, index, span) {\n    var _a;\n\n    var _b = this.props,\n        selection = _b.selection,\n        toggleWithoutModifierPressed = _b.toggleWithoutModifierPressed;\n    var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    var selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        if (span !== undefined) {\n          (_a = selection.selectToRange) === null || _a === void 0 ? void 0 : _a.call(selection, index, span, !isToggleModifierPressed);\n        } else {\n          selection.selectToIndex(index, !isToggleModifierPressed);\n        }\n      } else if (type === 'click' && (isToggleModifierPressed || toggleWithoutModifierPressed)) {\n        if (span !== undefined) {\n          selection.toggleRangeSelected(index, span);\n        } else {\n          selection.toggleIndexSelected(index);\n        }\n      } else {\n        this._clearAndSelectIndex(index, span);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index, span);\n    }\n  };\n\n  SelectionZone.prototype._onInvokeMouseDown = function (ev, index, span) {\n    var selection = this.props.selection;\n\n    if (span !== undefined) {\n      if (selection.isRangeSelected(index, span)) {\n        return;\n      }\n    } else {\n      // Only do work if item is not selected.\n      if (selection.isIndexSelected(index)) {\n        return;\n      }\n    }\n\n    this._clearAndSelectIndex(index, span);\n  };\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n\n\n  SelectionZone.prototype._findScrollParentAndTryClearOnEmptyClick = function (ev) {\n    var scrollParent = findScrollableParent(this._root.current); // unbind this handler and replace binding with a binding on the actual scrollable parent\n\n    this._events.off(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick); // If we clicked inside the scrollable parent, call through to the handler on this click.\n\n\n    if (scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  };\n\n  SelectionZone.prototype._tryClearOnEmptyClick = function (ev) {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target)) {\n      this.props.selection.setAllSelected(false);\n    }\n  };\n\n  SelectionZone.prototype._clearAndSelectIndex = function (index, span) {\n    var _a;\n\n    var _b = this.props,\n        selection = _b.selection,\n        _c = _b.selectionClearedOnSurfaceClick,\n        selectionClearedOnSurfaceClick = _c === void 0 ? true : _c;\n    var isAlreadySingleSelected = (span === undefined || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {\n      var isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      if (span !== undefined) {\n        (_a = selection.setRangeSelected) === null || _a === void 0 ? void 0 : _a.call(selection, index, span, true, true);\n      } else {\n        selection.setIndexSelected(index, true, true);\n      }\n\n      if (isModal || this.props.enterModalOnTouch && this._isTouch) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n\n      selection.setChangeEvents(true);\n    }\n  };\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n\n\n  SelectionZone.prototype._updateModifiers = function (ev) {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey; // eslint-disable-next-line deprecation/deprecation\n\n    var keyCode = ev.keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  };\n\n  SelectionZone.prototype._findItemRoot = function (target) {\n    var selection = this.props.selection;\n\n    while (target !== this._root.current) {\n      var indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      var index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target);\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  };\n\n  SelectionZone.prototype._getItemIndex = function (itemRoot) {\n    var _a;\n\n    var indexValue = parseInt((_a = itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME)) !== null && _a !== void 0 ? _a : '', 10);\n    return isNaN(indexValue) ? -1 : indexValue;\n  };\n\n  SelectionZone.prototype._getItemSpan = function (itemRoot) {\n    var _a;\n\n    var spanValue = parseInt((_a = itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME)) !== null && _a !== void 0 ? _a : '', 10);\n    return isNaN(spanValue) ? undefined : spanValue;\n  };\n\n  SelectionZone.prototype._shouldAutoSelect = function (element) {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  };\n\n  SelectionZone.prototype._hasAttribute = function (element, attributeName) {\n    var isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      var value = element.getAttribute(attributeName);\n\n      if (value === 'false') {\n        isToggle = false;\n        break;\n      }\n\n      isToggle = value === 'true';\n      element = getParent(element);\n    }\n\n    return isToggle;\n  };\n\n  SelectionZone.prototype._isInputElement = function (element) {\n    return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.getAttribute('contenteditable') === 'true' || element.getAttribute('contenteditable') === '';\n  };\n\n  SelectionZone.prototype._isNonHandledClick = function (element) {\n    var doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element) || element.hasAttribute('data-selection-index')) {\n          return false;\n        }\n\n        element = getParent(element);\n      }\n    }\n\n    return true;\n  };\n\n  SelectionZone.prototype._handleNextFocus = function (handleFocus) {\n    var _this = this;\n\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(function () {\n        _this._shouldHandleFocus = false;\n      }, 100);\n    }\n  };\n\n  SelectionZone.prototype._setIsTouch = function (isTouch) {\n    var _this = this;\n\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 300);\n    }\n  };\n\n  SelectionZone.prototype._getSelectionMode = function () {\n    var selection = this.props.selection;\n    var _a = this.props.selectionMode,\n        selectionMode = _a === void 0 ? selection ? selection.mode : SelectionMode.none : _a;\n    return selectionMode;\n  };\n\n  SelectionZone.defaultProps = {\n    isSelectedOnFocus: true,\n    toggleWithoutModifierPressed: false,\n    selectionMode: SelectionMode.multiple,\n    selectionClearedOnEscapePress: true\n  };\n  return SelectionZone;\n}(React.Component);\n\nexport { SelectionZone };","map":{"version":3,"mappings":"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","names":["React","Async","EventGroup","KeyCodes","elementContains","findScrollableParent","getParent","getDocument","getWindow","isElementTabbable","css","initializeComponentRef","FocusRects","SelectionMode","SELECTION_DISABLED_ATTRIBUTE_NAME","SELECTION_INDEX_ATTRIBUTE_NAME","SELECTION_SPAN_ATTRIBUTE_NAME","SELECTION_TOGGLE_ATTRIBUTE_NAME","SELECTION_INVOKE_ATTRIBUTE_NAME","SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME","SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME","SELECTION_SELECT_ATTRIBUTE_NAME","__extends","props","_super","_this","createRef","_handleNextFocus","selection","isModal","setState","ev","target","document","activeElement","ignoreNextFocus","_root","current","_hasAttribute","isToggleModifierPressed","_isCtrlPressed","_isMetaPressed","selectionMode","_getSelectionMode","_shouldHandleFocus","none","isToggle","itemRoot","_findItemRoot","index","_getItemIndex","span","_getItemSpan","undefined","setIndexSelected","isIndexSelected","enterModalOnTouch","_isTouch","setModal","_setIsTouch","isSelectedOnFocus","_onItemSurfaceClick","_updateModifiers","toggleWithoutModifierPressed","_isSelectionDisabled","_shouldAutoSelect","_isShiftPressed","_onInvokeMouseDown","disableAutoSelectOnInputElements","tagName","enableTouchInvocationTarget","_a","isSelectionDisabled","_onToggleAllClick","_onToggleClick","_onInvokeClick","onItemContextMenu","skipPreventDefault","getItems","nativeEvent","preventDefault","onItemInvoked","_isInputElement","selectionClearedOnEscapePress","isSelectAllKey","which","a","isClearSelectionKey","escape","multiple","isAllSelected","setAllSelected","stopPropagation","getSelectedCount","enter","space","_events","_async","state","SelectionZone","nextProps","prevState","win","on","_findScrollParentAndTryClearOnEmptyClick","body","_onTouchStartCapture","_onSelectionChange","className","ref","onKeyDown","_onKeyDown","onMouseDown","_onMouseDown","onKeyDownCapture","_onKeyDownCapture","onClick","_onClick","role","onDoubleClick","_onDoubleClick","onContextMenu","_onContextMenu","onMouseDownCapture","_onMouseDownCapture","onFocusCapture","_onFocus","children","previousProps","off","dispose","toggleAllSelected","setChangeEvents","isRangeSelected","toggleRangeSelected","toggleIndexSelected","single","isSelected","type","_isTabPressed","selectToRange","selectToIndex","_clearAndSelectIndex","scrollParent","_tryClearOnEmptyClick","Node","contains","selectionPreservedOnEmptyClick","_isNonHandledClick","_c","selectionClearedOnSurfaceClick","isAlreadySingleSelected","setRangeSelected","shiftKey","ctrlKey","metaKey","keyCode","tab","indexValue","getAttribute","Number","length","parseInt","isNaN","spanValue","element","attributeName","value","doc","documentElement","hasAttribute","handleFocus","_shouldHandleFocusTimeoutId","clearTimeout","setTimeout","isTouch","_isTouchTimeoutId","mode","Component"],"sources":["/Users/aalyanmahmood/Documents/GitHub/OffCampus-Mac/node_modules/@fluentui/react/lib/utilities/src/utilities/selection/SelectionZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  KeyCodes,\n  elementContains,\n  findScrollableParent,\n  getParent,\n  getDocument,\n  getWindow,\n  isElementTabbable,\n  css,\n  initializeComponentRef,\n  FocusRects,\n} from '../../Utilities';\nimport { SelectionMode } from './interfaces';\nimport type { ISelection, IObjectWithKey } from './interfaces';\n\n// Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nconst SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nconst SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nconst SELECTION_SPAN_ATTRIBUTE_NAME = 'data-selection-span';\nconst SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nconst SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nconst SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nconst SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nconst SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZone {\n  /**\n   * Method to ignore subsequent focus.\n   */\n  ignoreNextFocus: () => void;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {\n  children?: React.ReactNode;\n  /**\n   * Reference to the component interface.\n   */\n  componentRef?: () => void;\n  /**\n   * Required {@link ISelection} instance bound to the {@link SelectionZone}.\n   */\n  selection: ISelection;\n  /**\n   * @deprecated No longer in use, focus is now managed by {@link FocusZone}.\n   */\n  layout?: {};\n  /**\n   * The mode of Selection, where the value is one of\n   * 'none', 'single', or 'multiple'.\n   *\n   * @defaultvalue {@link SelectionMode.multiple}\n   */\n  selectionMode?: SelectionMode;\n  /**\n   * If true, selection is preserved on outer click.\n   */\n  selectionPreservedOnEmptyClick?: boolean;\n  /**\n   * If true, disables automatic selection on input elements.\n   */\n  disableAutoSelectOnInputElements?: boolean;\n  /**\n   * If true, modal selection is enabled on touch event.\n   */\n  enterModalOnTouch?: boolean;\n  /**\n   * Determines whether elements with the attribute `data-selection-touch-invoke` should be used as invocation targets\n   * for an item if the user is using touch.\n   *\n   * @defaultvalue false\n   */\n  enableTouchInvocationTarget?: boolean;\n  /**\n   * Determines if an item is selected on focus.\n   *\n   * @defaultvalue true\n   */\n  isSelectedOnFocus?: boolean;\n  /**\n   * Determines if elements within the selection zone that DO NOT have the 'data-selection-toggle' or\n   * 'data-selection-all-toggle' attribute are clickable and can alter the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnSurfaceClick?: boolean;\n\n  /**\n   * Determines if pressing the Escape clears the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnEscapePress?: boolean;\n\n  /**\n   * Allows the default toggle behavior to be overridden.\n   * When set to `true` users do not have press a modifier key (e.g., ctrl or meta)\n   * to toggle values.\n   *\n   * @default false\n   */\n  toggleWithoutModifierPressed?: boolean;\n\n  /**\n   * Optional callback for when an item is\n   * invoked via ENTER or double-click.\n   */\n  onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;\n  /**\n   * Optional callback for when an\n   * item's contextual menu action occurs.\n   */\n  onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;\n  /**\n   * Additional CSS class(es) to apply to the SelectionZone.\n   */\n  className?: string;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneState {\n  isModal: boolean | undefined;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport class SelectionZone extends React.Component<ISelectionZoneProps, ISelectionZoneState> {\n  public static defaultProps = {\n    isSelectedOnFocus: true,\n    toggleWithoutModifierPressed: false,\n    selectionMode: SelectionMode.multiple,\n    selectionClearedOnEscapePress: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _isCtrlPressed: boolean;\n  private _isShiftPressed: boolean;\n  private _isMetaPressed: boolean;\n  private _isTabPressed: boolean;\n  private _shouldHandleFocus: boolean;\n  private _shouldHandleFocusTimeoutId: number | undefined;\n  private _isTouch: boolean;\n  private _isTouchTimeoutId: number | undefined;\n\n  public static getDerivedStateFromProps(\n    nextProps: ISelectionZoneProps,\n    prevState: ISelectionZoneState,\n  ): ISelectionZoneState {\n    const isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n\n    return {\n      ...prevState,\n      isModal,\n    };\n  }\n\n  constructor(props: ISelectionZoneProps) {\n    super(props);\n\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n    initializeComponentRef(this);\n\n    const { selection } = this.props;\n\n    // Reflect the initial modal state of selection into the state.\n    const isModal = selection.isModal && selection.isModal();\n\n    this.state = {\n      isModal,\n    };\n  }\n\n  public componentDidMount(): void {\n    const win = getWindow(this._root.current);\n\n    // Track the latest modifier keys globally.\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n    this._events.on(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);\n    this._events.on(document.body, 'touchend', this._onTouchStartCapture, true);\n\n    // Subscribe to the selection to keep modal state updated.\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  }\n\n  public render(): JSX.Element {\n    const { isModal } = this.state;\n\n    return (\n      <div\n        className={css('ms-SelectionZone', this.props.className, {\n          'ms-SelectionZone--modal': !!isModal,\n        })}\n        ref={this._root}\n        onKeyDown={this._onKeyDown}\n        onMouseDown={this._onMouseDown}\n        onKeyDownCapture={this._onKeyDownCapture}\n        onClick={this._onClick}\n        role=\"presentation\"\n        onDoubleClick={this._onDoubleClick}\n        onContextMenu={this._onContextMenu}\n        onMouseDownCapture={this._onMouseDownCapture}\n        onFocusCapture={this._onFocus}\n        data-selection-is-modal={isModal ? true : undefined}\n      >\n        {this.props.children}\n        <FocusRects />\n      </div>\n    );\n  }\n\n  public componentDidUpdate(previousProps: ISelectionZoneProps): void {\n    const { selection } = this.props;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  /**\n   * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n   * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n   * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n   * focus event that occurs. This method does that.\n   */\n  public ignoreNextFocus = (): void => {\n    this._handleNextFocus(false);\n  };\n\n  private _onSelectionChange = (): void => {\n    const { selection } = this.props;\n\n    const isModal = selection.isModal && selection.isModal();\n\n    this.setState({\n      isModal,\n    });\n  };\n\n  private _onMouseDownCapture = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    if (document.activeElement !== target && !elementContains(document.activeElement as HTMLElement, target)) {\n      this.ignoreNextFocus();\n      return;\n    }\n\n    if (!elementContains(target, this._root.current)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n        this.ignoreNextFocus();\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  /**\n   * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n   * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n   * specially.\n   */\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n    const { selection } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n      const isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n      const itemRoot = this._findItemRoot(target);\n\n      if (!isToggle && itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (span === undefined) {\n          if (isToggleModifierPressed) {\n            // set anchor only.\n            selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n            if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {\n              selection.setModal(true);\n              this._setIsTouch(false);\n            }\n          } else {\n            if (this.props.isSelectedOnFocus) {\n              this._onItemSurfaceClick('focus', index);\n            }\n          }\n        }\n      }\n    }\n\n    this._handleNextFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    const { toggleWithoutModifierPressed } = this.props;\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    // No-op if selection is disabled\n    if (this._isSelectionDisabled(target)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        break;\n      } else if (itemRoot) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (\n          (target === itemRoot || this._shouldAutoSelect(target)) &&\n          !this._isShiftPressed &&\n          !this._isCtrlPressed &&\n          !this._isMetaPressed &&\n          !toggleWithoutModifierPressed\n        ) {\n          this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot), this._getItemSpan(itemRoot));\n\n          break;\n        } else if (\n          this.props.disableAutoSelectOnInputElements &&\n          (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')\n        ) {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onTouchStartCapture = (ev: React.TouchEvent<HTMLElement>): void => {\n    this._setIsTouch(true);\n  };\n\n  private _onClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { enableTouchInvocationTarget = false } = this.props;\n\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        if (!isSelectionDisabled) {\n          this._onToggleAllClick(ev);\n        }\n        break;\n      } else if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            if (this._isShiftPressed) {\n              this._onItemSurfaceClick('click', index, span);\n            } else {\n              this._onToggleClick(ev, index, span);\n            }\n          }\n          break;\n        } else if (\n          (this._isTouch &&\n            enableTouchInvocationTarget &&\n            this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME)) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          if (span === undefined) {\n            // Items should be invokable even if selection is disabled.\n            this._onInvokeClick(ev, index);\n          }\n          break;\n        } else if (target === itemRoot) {\n          if (!isSelectionDisabled) {\n            this._onItemSurfaceClick('click', index, span);\n          }\n          break;\n        } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onContextMenu = (ev: React.MouseEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n\n    const { onItemContextMenu, selection } = this.props;\n    if (onItemContextMenu) {\n      const itemRoot = this._findItemRoot(target);\n\n      if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        this._onInvokeMouseDown(ev, index);\n\n        const skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);\n\n        // In order to keep back compat, if the value here is undefined, then we should still\n        // call preventDefault(). Only in the case where true is explicitly returned should\n        // the call be skipped.\n        if (!skipPreventDefault) {\n          ev.preventDefault();\n        }\n      }\n    }\n  };\n\n  private _isSelectionDisabled(target: HTMLElement): boolean {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n      target = getParent(target) as HTMLElement;\n    }\n\n    return false;\n  }\n\n  /**\n   * In multi selection, if you double click within an item's root (but not within the invoke element or\n   * input elements), we should execute the invoke handler.\n   */\n  private _onDoubleClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    const { onItemInvoked } = this.props;\n    const itemRoot = this._findItemRoot(target);\n\n    if (itemRoot && onItemInvoked && !this._isInputElement(target)) {\n      const index = this._getItemIndex(itemRoot);\n\n      while (target !== this._root.current) {\n        if (\n          this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          break;\n        } else if (target === itemRoot) {\n          this._onInvokeClick(ev, index);\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onKeyDownCapture = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    this._handleNextFocus(true);\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    const { selection, selectionClearedOnEscapePress } = this.props;\n    // eslint-disable-next-line deprecation/deprecation\n    const isSelectAllKey = ev.which === KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);\n    // eslint-disable-next-line deprecation/deprecation\n    const isClearSelectionKey = ev.which === KeyCodes.escape;\n\n    // Ignore key downs from input elements.\n    if (this._isInputElement(target)) {\n      // A key was pressed while an item in this zone was focused.\n      return;\n    }\n\n    const selectionMode = this._getSelectionMode();\n\n    // If ctrl-a is pressed, select all (if all are not already selected.)\n    if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(true);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    // If escape is pressed and the component is configured to clear on escape press,\n    // clear selection (if any are selected.)\n    if (selectionClearedOnEscapePress && isClearSelectionKey && selection.getSelectedCount() > 0) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(false);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    const itemRoot = this._findItemRoot(target);\n\n    // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n    if (itemRoot) {\n      const index = this._getItemIndex(itemRoot);\n      const span = this._getItemSpan(itemRoot);\n\n      while (target !== this._root.current) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n          // so we can no-op for any keydowns in this case.\n          break;\n        } else if (this._shouldAutoSelect(target)) {\n          if (!isSelectionDisabled && span === undefined) {\n            // If the event went to an element which should trigger auto-select, select it and then let\n            // the default behavior kick in.\n            this._onInvokeMouseDown(ev, index, span);\n          }\n          break;\n        } else if (\n          // eslint-disable-next-line deprecation/deprecation\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) &&\n          (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT')\n        ) {\n          return false;\n        } else if (target === itemRoot) {\n          // eslint-disable-next-line deprecation/deprecation\n          if (ev.which === KeyCodes.enter) {\n            if (span === undefined) {\n              // Items should be invokable even if selection is disabled.\n              this._onInvokeClick(ev, index);\n              ev.preventDefault();\n            }\n            return;\n            // eslint-disable-next-line deprecation/deprecation\n          } else if (ev.which === KeyCodes.space) {\n            if (!isSelectionDisabled) {\n              this._onToggleClick(ev, index, span);\n            }\n            ev.preventDefault();\n            return;\n          }\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n    }\n  };\n\n  private _onToggleAllClick(ev: React.MouseEvent<HTMLElement>): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  }\n\n  private _onToggleClick(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (\n      this.props.enterModalOnTouch &&\n      this._isTouch &&\n      (span !== undefined ? !selection.isRangeSelected(index, span) : !selection.isIndexSelected(index)) &&\n      selection.setModal\n    ) {\n      selection.setModal(true);\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (span !== undefined) {\n        selection.toggleRangeSelected(index, span);\n      } else {\n        selection.toggleIndexSelected(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      if (span === undefined || span === 1) {\n        const isSelected = selection.isIndexSelected(index);\n        const isModal = selection.isModal && selection.isModal();\n        selection.setAllSelected(false);\n        selection.setIndexSelected(index, !isSelected, true);\n        if (isModal && selection.setModal) {\n          // Since the above call to setAllSelected(false) clears modal state,\n          // restore it. This occurs because the SelectionMode of the Selection\n          // may differ from the SelectionZone.\n          selection.setModal(true);\n        }\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n\n    ev.stopPropagation();\n\n    // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  }\n\n  private _onInvokeClick(ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, index: number): void {\n    const { selection, onItemInvoked } = this.props;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _onItemSurfaceClick(type: 'focus' | 'click', index: number, span?: number): void {\n    const { selection, toggleWithoutModifierPressed } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        if (span !== undefined) {\n          selection.selectToRange?.(index, span, !isToggleModifierPressed);\n        } else {\n          selection.selectToIndex(index, !isToggleModifierPressed);\n        }\n      } else if (type === 'click' && (isToggleModifierPressed || toggleWithoutModifierPressed)) {\n        if (span !== undefined) {\n          selection.toggleRangeSelected(index, span);\n        } else {\n          selection.toggleIndexSelected(index);\n        }\n      } else {\n        this._clearAndSelectIndex(index, span);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index, span);\n    }\n  }\n\n  private _onInvokeMouseDown(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    if (span !== undefined) {\n      if (selection.isRangeSelected(index, span)) {\n        return;\n      }\n    } else {\n      // Only do work if item is not selected.\n      if (selection.isIndexSelected(index)) {\n        return;\n      }\n    }\n\n    this._clearAndSelectIndex(index, span);\n  }\n\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n  private _findScrollParentAndTryClearOnEmptyClick(ev: MouseEvent) {\n    const scrollParent = findScrollableParent(this._root.current) as HTMLElement;\n    // unbind this handler and replace binding with a binding on the actual scrollable parent\n    this._events.off(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick);\n\n    // If we clicked inside the scrollable parent, call through to the handler on this click.\n    if ((scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target)) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  }\n\n  private _tryClearOnEmptyClick(ev: MouseEvent): void {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target as HTMLElement)) {\n      this.props.selection.setAllSelected(false);\n    }\n  }\n\n  private _clearAndSelectIndex(index: number, span?: number): void {\n    const { selection, selectionClearedOnSurfaceClick = true } = this.props;\n    const isAlreadySingleSelected =\n      (span === undefined || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {\n      const isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      if (span !== undefined) {\n        selection.setRangeSelected?.(index, span, true, true);\n      } else {\n        selection.setIndexSelected(index, true, true);\n      }\n      if (isModal || (this.props.enterModalOnTouch && this._isTouch)) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n      selection.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n  private _updateModifiers(ev: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n\n    // eslint-disable-next-line deprecation/deprecation\n    const keyCode = (ev as React.KeyboardEvent<HTMLElement>).keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  }\n\n  private _findItemRoot(target: HTMLElement): HTMLElement | undefined {\n    const { selection } = this.props;\n\n    while (target !== this._root.current) {\n      const indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      const index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  }\n\n  private _getItemIndex(itemRoot: HTMLElement): number {\n    const indexValue = parseInt(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(indexValue) ? -1 : indexValue;\n  }\n\n  private _getItemSpan(itemRoot: HTMLElement): number | undefined {\n    const spanValue = parseInt(itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(spanValue) ? undefined : spanValue;\n  }\n\n  private _shouldAutoSelect(element: HTMLElement): boolean {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  }\n\n  private _hasAttribute(element: HTMLElement, attributeName: string): boolean {\n    let isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      const value = element.getAttribute(attributeName);\n      if (value === 'false') {\n        isToggle = false;\n        break;\n      }\n      isToggle = value === 'true';\n      element = getParent(element) as HTMLElement;\n    }\n\n    return isToggle;\n  }\n\n  private _isInputElement(element: HTMLElement): boolean {\n    return (\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.getAttribute('contenteditable') === 'true' ||\n      element.getAttribute('contenteditable') === ''\n    );\n  }\n\n  private _isNonHandledClick(element: HTMLElement): boolean {\n    const doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element) || element.hasAttribute('data-selection-index')) {\n          return false;\n        }\n\n        element = getParent(element) as HTMLElement;\n      }\n    }\n\n    return true;\n  }\n\n  private _handleNextFocus(handleFocus: boolean): void {\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(() => {\n        this._shouldHandleFocus = false;\n      }, 100);\n    }\n  }\n\n  private _setIsTouch(isTouch: boolean): void {\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 300);\n    }\n  }\n\n  private _getSelectionMode(): SelectionMode {\n    const { selection } = this.props;\n\n    const { selectionMode = selection ? selection.mode : SelectionMode.none } = this.props;\n\n    return selectionMode;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}