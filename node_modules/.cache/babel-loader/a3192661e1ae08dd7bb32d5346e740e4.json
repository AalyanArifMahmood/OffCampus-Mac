{"ast":null,"code":"import { __assign, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, assign, classNamesFunction, css, getFirstFocusable, getLastFocusable, getRTL, KeyCodes, shouldWrapFocus, isIOS, isMac, memoizeFunction, getPropsWithDefaults, getDocument, FocusRects } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { useTarget, usePrevious, useAsync, useWarnings, useId, useIsomorphicLayoutEffect } from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction(); // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\nvar DEFAULT_PROPS = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16\n};\nexport function getSubmenuItems(item, options) {\n  var target = options === null || options === void 0 ? void 0 : options.target; // eslint-disable-next-line deprecation/deprecation\n\n  var items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    var overrideItems = [];\n\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n      var subItem = items_1[_i];\n\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        var onClick = subItem.onClick,\n            contextItem = __rest(subItem, [\"onClick\"]);\n\n        overrideItems.push(__assign(__assign({}, contextItem), {\n          onClick: getOnClickWithOverrideTarget(onClick, target)\n        }));\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250;\n/* ms */\n\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles));\n  };\n}); //#region Custom hooks\n\n\nfunction useVisibility(props, targetWindow) {\n  var _a = props.hidden,\n      hidden = _a === void 0 ? false : _a,\n      onMenuDismissed = props.onMenuDismissed,\n      onMenuOpened = props.onMenuOpened;\n  var previousHidden = usePrevious(hidden);\n  var onMenuOpenedRef = React.useRef(onMenuOpened);\n  var onMenuClosedRef = React.useRef(onMenuDismissed);\n  var propsRef = React.useRef(props);\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n  React.useEffect(function () {\n    var _a, _b; // Don't issue dismissed callbacks on initial mount\n\n\n    if (hidden && previousHidden === false) {\n      (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);\n    }\n  }, [hidden, previousHidden]); // Issue onDismissedCallback on unmount\n\n  React.useEffect(function () {\n    return function () {\n      var _a;\n\n      return (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    };\n  }, []);\n}\n\nfunction useSubMenuState(_a, dismiss) {\n  var hidden = _a.hidden,\n      items = _a.items,\n      theme = _a.theme,\n      className = _a.className,\n      id = _a.id,\n      menuTarget = _a.target;\n\n  var _b = React.useState(),\n      expandedMenuItemKey = _b[0],\n      setExpandedMenuItemKey = _b[1];\n\n  var _c = React.useState(),\n      submenuTarget = _c[0],\n      setSubmenuTarget = _c[1];\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n\n\n  var _d = React.useState(),\n      shouldFocusOnContainer = _d[0],\n      setShouldFocusOnContainer = _d[1];\n\n  var subMenuId = useId(COMPONENT_NAME, id);\n  var closeSubMenu = React.useCallback(function () {\n    setShouldFocusOnContainer(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n  var openSubMenu = React.useCallback(function (_a, target, focusContainer) {\n    var submenuItemKey = _a.key;\n\n    if (expandedMenuItemKey === submenuItemKey) {\n      return;\n    }\n\n    target.focus();\n    setShouldFocusOnContainer(focusContainer);\n    setExpandedMenuItemKey(submenuItemKey);\n    setSubmenuTarget(target);\n  }, [expandedMenuItemKey]);\n  React.useEffect(function () {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  var getSubmenuProps = function () {\n    var item = findItemByKeyFromItems(expandedMenuItemKey, items);\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item, {\n          target: menuTarget\n        }),\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: shouldFocusOnContainer,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        var onItemClick = item.onItemClick;\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];\n}\n\nfunction useShouldUpdateFocusOnMouseMove(_a) {\n  var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover,\n      hidden = _a.hidden;\n  var shouldUpdateFocusOnMouseEvent = React.useRef(!delayUpdateFocusOnHover);\n  var gotMouseMove = React.useRef(false);\n  React.useEffect(function () {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n  var onMenuFocusCapture = React.useCallback(function () {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = false;\n    }\n  }, [delayUpdateFocusOnHover]);\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];\n}\n\nfunction usePreviousActiveElement(_a, targetWindow) {\n  var hidden = _a.hidden,\n      onRestoreFocus = _a.onRestoreFocus;\n  var previousElementsQueue = React.useRef([]);\n  var tryFocusPreviousActiveElement = React.useCallback(function (options) {\n    var _a, _b;\n\n    if (onRestoreFocus) {\n      onRestoreFocus(options);\n    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {\n      // Make sure that the focus method actually exists\n      // In some cases the object might exist but not be a real element.\n      // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n      (_b = (_a = previousElementsQueue.current[0]) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }, [onRestoreFocus]);\n  useIsomorphicLayoutEffect(function () {\n    var _a;\n\n    if (!hidden) {\n      var targetElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;\n      var targetPosition = previousElementsQueue.current.indexOf(targetElement);\n\n      if (targetPosition > -1) {\n        previousElementsQueue.current = previousElementsQueue.current.slice(targetPosition + 1);\n      } else {\n        previousElementsQueue.current = __spreadArray([targetElement], previousElementsQueue.current);\n      }\n    } else if (previousElementsQueue.current.length > 0) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousElementsQueue.current[0],\n        containsFocus: true,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n      previousElementsQueue.current = [];\n    }\n  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);\n  return [tryFocusPreviousActiveElement];\n}\n\nfunction useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {\n  var theme = _a.theme,\n      isSubMenu = _a.isSubMenu,\n      _b = _a.focusZoneProps,\n      _c = _b === void 0 ? {} : _b,\n      checkForNoWrap = _c.checkForNoWrap,\n      _d = _c.direction,\n      focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n\n\n  var lastKeyDownWasAltOrMeta = React.useRef();\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n\n  var keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n    var handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n  /**\n   * Checks if the submenu should be closed\n   */\n\n\n  var shouldCloseSubMenu = function (ev) {\n    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left; // eslint-disable-next-line deprecation/deprecation\n\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap'));\n  };\n\n  var shouldHandleKeyDown = function (ev) {\n    return (// eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)\n    );\n  };\n\n  var onKeyDown = function (ev) {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n\n    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n\n\n  var shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  var onKeyUp = function (ev) {\n    return keyHandler(ev, shouldHandleKeyUp, true\n    /* dismissAllMenus */\n    );\n  };\n\n  var onMenuKeyDown = function (ev) {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    var handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    } // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n\n\n    var hasModifier = !!(ev.altKey || ev.metaKey); // eslint-disable-next-line deprecation/deprecation\n\n    var isUp = ev.which === KeyCodes.up; // eslint-disable-next-line deprecation/deprecation\n\n    var isDown = ev.which === KeyCodes.down;\n\n    if (!hasModifier && (isUp || isDown)) {\n      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  var onItemKeyDown = function (item, ev) {\n    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (!item.disabled && ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n      openSubMenu(item, ev.currentTarget);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];\n}\n\nfunction useScrollHandler(asyncTracker) {\n  var isScrollIdle = React.useRef(true);\n  var scrollIdleTimeoutId = React.useRef();\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n\n  var onScroll = function () {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function () {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle];\n}\n\nfunction useOnSubmenuDismiss(dismiss, closeSubMenu) {\n  var isMountedRef = React.useRef(false);\n  React.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n\n  var onSubMenuDismiss = function (ev, dismissAll) {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer(_a, asyncTracker) {\n  var _b = _a.subMenuHoverDelay,\n      subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;\n  var enterTimerRef = React.useRef(undefined);\n\n  var cancelSubMenuTimer = function () {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  var startSubmenuTimer = function (onTimerExpired) {\n    enterTimerRef.current = asyncTracker.setTimeout(function () {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];\n}\n\nfunction useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {\n  var menuTarget = props.target;\n\n  var onItemMouseEnterBase = function (item, ev, target) {\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    }\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var onItemMouseMoveBase = function (item, ev, target) {\n    var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (!isScrollIdle.current || subMenuEntryTimer.current !== undefined || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var shouldIgnoreMouseEvent = function () {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  var onMouseItemLeave = function (item, ev) {\n    var _a;\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n\n\n    if (hostElement.current.setActive) {\n      try {\n        hostElement.current.setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  var updateFocusOnMouseEvent = function (item, ev, target) {\n    var targetElement = target ? target : ev.currentTarget;\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer(); // If the menu is not expanded we can update focus without any delay\n\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(function () {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(function () {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  var onItemClick = function (item, ev) {\n    onItemClickBase(item, ev, ev.currentTarget);\n  };\n\n  var onItemClickBase = function (item, ev, target) {\n    var items = getSubmenuItems(item, {\n      target: menuTarget\n    }); // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        // focus on the container by default when the menu is opened with a click event\n        // this differentiates from a keyboard interaction triggering the click event\n        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === 'boolean' ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === 'mouse';\n        openSubMenu(item, target, shouldFocusOnContainer);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  var onAnchorClick = function (item, ev) {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  var executeItemClick = function (item, ev) {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    var shouldDismiss = false;\n\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [onItemMouseEnterBase, onItemMouseMoveBase, onMouseItemLeave, onItemClick, onAnchorClick, executeItemClick, onItemClickBase];\n} //#endregion\n\n\nexport var ContextualMenuBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a;\n\n  var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n      ref = _b.ref,\n      props = __rest(_b, [\"ref\"]);\n\n  var hostElement = React.useRef(null);\n  var asyncTracker = useAsync();\n  var menuId = useId(COMPONENT_NAME, props.id);\n  useWarnings({\n    name: COMPONENT_NAME,\n    props: props,\n    deprecations: {\n      getMenuClassNames: 'styles'\n    }\n  });\n\n  var dismiss = function (ev, dismissAll) {\n    var _a;\n\n    return (_a = props.onDismiss) === null || _a === void 0 ? void 0 : _a.call(props, ev, dismissAll);\n  };\n\n  var _c = useTarget(props.target, hostElement),\n      targetRef = _c[0],\n      targetWindow = _c[1];\n\n  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];\n\n  var _d = useSubMenuState(props, dismiss),\n      expandedMenuItemKey = _d[0],\n      openSubMenu = _d[1],\n      getSubmenuProps = _d[2],\n      onSubMenuDismiss = _d[3];\n\n  var _e = useShouldUpdateFocusOnMouseMove(props),\n      shouldUpdateFocusOnMouseEvent = _e[0],\n      gotMouseMove = _e[1],\n      onMenuFocusCapture = _e[2];\n\n  var _f = useScrollHandler(asyncTracker),\n      onScroll = _f[0],\n      isScrollIdle = _f[1];\n\n  var _g = useSubmenuEnterTimer(props, asyncTracker),\n      cancelSubMenuTimer = _g[0],\n      startSubmenuTimer = _g[1],\n      subMenuEntryTimer = _g[2];\n\n  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n  useVisibility(props, targetWindow);\n\n  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu),\n      onKeyDown = _h[0],\n      onKeyUp = _h[1],\n      onMenuKeyDown = _h[2],\n      onItemKeyDown = _h[3];\n\n  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss),\n      onItemMouseEnterBase = _j[0],\n      onItemMouseMoveBase = _j[1],\n      onMouseItemLeave = _j[2],\n      onItemClick = _j[3],\n      onAnchorClick = _j[4],\n      executeItemClick = _j[5],\n      onItemClickBase = _j[6]; //#region Render helpers\n\n\n  var onDefaultRenderMenuList = function (menuListProps, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, defaultRender) {\n    var indexCorrection = 0;\n    var items = menuListProps.items,\n        totalItemCount = menuListProps.totalItemCount,\n        hasCheckmarks = menuListProps.hasCheckmarks,\n        hasIcons = menuListProps.hasIcons;\n    return React.createElement(\"ul\", {\n      className: menuClassNames.list,\n      onKeyDown: onKeyDown,\n      onKeyUp: onKeyUp,\n      role: 'presentation'\n    }, items.map(function (item, index) {\n      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        indexCorrection += indexIncrease;\n      }\n\n      return menuItem;\n    }));\n  };\n\n  var renderFocusZone = function (children, adjustedFocusZoneProps) {\n    var _a = props.focusZoneAs,\n        ChildrenRenderer = _a === void 0 ? FocusZone : _a;\n    return React.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps), children);\n  };\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n\n\n  var renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var _a;\n\n    var renderedItems = [];\n    var iconProps = item.iconProps || {\n      iconName: 'None'\n    };\n    var getItemClassNames = item.getItemClassNames,\n        // eslint-disable-line deprecation/deprecation\n    itemProps = item.itemProps;\n    var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n\n    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n    var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n    } else {\n      var itemStyleProps = {\n        theme: props.theme,\n        disabled: isItemDisabled(item),\n        expanded: expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName: dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      }; // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n\n      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = menuClassNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n    } // eslint-disable-next-line deprecation/deprecation\n\n\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        break;\n\n      case ContextualMenuItemType.Header:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n\n      case ContextualMenuItemType.Section:\n        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n        break;\n\n      default:\n        var defaultRenderNormalItem = function () {\n          return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n        };\n\n        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem) : defaultRenderNormalItem();\n        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n    return React.createElement(React.Fragment, {\n      key: item.key\n    }, renderedItems);\n  };\n\n  var defaultMenuItemRenderer = function (item, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var index = item.index,\n        focusableElementIndex = item.focusableElementIndex,\n        totalItemCount = item.totalItemCount,\n        hasCheckmarks = item.hasCheckmarks,\n        hasIcons = item.hasIcons;\n    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n  };\n\n  var renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabelledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id_1 = menuId + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id_1\n        };\n        ariaLabelledby = id_1;\n      } else {\n        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), {\n          id: id_2\n        });\n        ariaLabelledby = id_2;\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabelledby\n        };\n        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: menuClassNames.list,\n        role: \"presentation\"\n      }, sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true), headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons, menuClassNames);\n      }), sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true))));\n    }\n  };\n\n  var renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  var renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  var renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), dismiss);\n    }\n\n    var contextualMenuItemAs = props.contextualMenuItemAs;\n    var commonProps = {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: onItemMouseEnterBase,\n      onItemMouseLeave: onMouseItemLeave,\n      onItemMouseMove: onItemMouseMoveBase,\n      onItemMouseDown: onItemMouseDown,\n      executeItemClick: executeItemClick,\n      onItemKeyDown: onItemKeyDown,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: openSubMenu,\n      dismissSubMenu: onSubMenuDismiss,\n      dismissMenu: dismiss\n    };\n\n    if (item.href) {\n      return React.createElement(ContextualMenuAnchor, __assign({}, commonProps, {\n        onItemClick: onAnchorClick\n      }));\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return React.createElement(ContextualMenuSplitButton, __assign({}, commonProps, {\n        onItemClick: onItemClick,\n        onItemClickBase: onItemClickBase,\n        onTap: cancelSubMenuTimer\n      }));\n    }\n\n    return React.createElement(ContextualMenuButton, __assign({}, commonProps, {\n      onItemClick: onItemClick,\n      onItemClickBase: onItemClickBase\n    }));\n  };\n\n  var renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _a = props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: menuClassNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: itemClassNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  }; //#endregion\n  //#region Main render\n\n\n  var isBeakVisible = props.isBeakVisible;\n  var items = props.items,\n      labelElementId = props.labelElementId,\n      id = props.id,\n      className = props.className,\n      beakWidth = props.beakWidth,\n      directionalHint = props.directionalHint,\n      directionalHintForRTL = props.directionalHintForRTL,\n      alignTargetEdge = props.alignTargetEdge,\n      gapSpace = props.gapSpace,\n      coverTarget = props.coverTarget,\n      ariaLabel = props.ariaLabel,\n      doNotLayer = props.doNotLayer,\n      target = props.target,\n      bounds = props.bounds,\n      useTargetWidth = props.useTargetWidth,\n      useTargetAsMinWidth = props.useTargetAsMinWidth,\n      directionalHintFixed = props.directionalHintFixed,\n      shouldFocusOnMount = props.shouldFocusOnMount,\n      shouldFocusOnContainer = props.shouldFocusOnContainer,\n      title = props.title,\n      styles = props.styles,\n      theme = props.theme,\n      calloutProps = props.calloutProps,\n      _k = props.onRenderSubMenu,\n      onRenderSubMenu = _k === void 0 ? onDefaultRenderSubMenu : _k,\n      _l = props.onRenderMenuList,\n      onRenderMenuList = _l === void 0 ? function (menuListProps, defaultRender) {\n    return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n  } : _l,\n      focusZoneProps = props.focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n  getMenuClassNames = props.getMenuClassNames;\n  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n    theme: theme,\n    className: className\n  });\n  var hasIcons = itemsHaveIcons(items);\n\n  function itemsHaveIcons(contextualMenuItems) {\n    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n      var item = contextualMenuItems_1[_i];\n\n      if (item.iconProps) {\n        return true;\n      }\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var adjustedFocusZoneProps = __assign(__assign({\n    direction: FocusZoneDirection.vertical,\n    handleTabKey: FocusZoneTabbableElements.all,\n    isCircularNavigation: true\n  }, focusZoneProps), {\n    className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className)\n  });\n\n  var hasCheckmarks = canAnyMenuItemsCheck(items);\n  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n  isBeakVisible = isBeakVisible === undefined ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n  /**\n   * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n   */\n\n  var contextMenuStyle;\n  var targetAsHtmlElement = targetRef.current;\n\n  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n    var targetWidth = targetBoundingRect.width - 2;\n    /* Accounts for 1px border */\n\n    if (useTargetWidth) {\n      contextMenuStyle = {\n        width: targetWidth\n      };\n    } else if (useTargetAsMinWidth) {\n      contextMenuStyle = {\n        minWidth: targetWidth\n      };\n    }\n  } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n  if (items && items.length > 0) {\n    var totalItemCount_1 = 0;\n\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        totalItemCount_1 += itemCount;\n      }\n    }\n\n    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : undefined;\n    return React.createElement(MenuContext.Consumer, null, function (menuContext) {\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles_1,\n        onRestoreFocus: tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target || menuContext.target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: props.onDismiss || menuContext.onDismiss,\n        onScroll: onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: props.hidden || menuContext.hidden,\n        ref: forwardedRef\n      }), React.createElement(\"div\", {\n        style: contextMenuStyle,\n        ref: hostElement,\n        id: id,\n        className: classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: onMenuKeyDown,\n        onKeyUp: onKeyUp,\n        onFocusCapture: onMenuFocusCapture,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        role: 'menu'\n      }, title && React.createElement(\"div\", {\n        className: classNames.title\n      }, \" \", title, \" \"), items && items.length ? renderFocusZone(onRenderMenuList({\n        ariaLabel: ariaLabel,\n        items: items,\n        totalItemCount: totalItemCount_1,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: function (item) {\n          return defaultMenuItemRenderer(item, classNames);\n        },\n        labelElementId: labelElementId\n      }, function (menuListProps, defaultRender) {\n        return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n      }), adjustedFocusZoneProps) : null, submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)), React.createElement(FocusRects, null));\n    });\n  } else {\n    return null;\n  } //#endregion\n\n}), function (prevProps, newProps) {\n  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(prevProps, newProps);\n});\nContextualMenuBase.displayName = 'ContextualMenuBase';\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\n\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item, ev) {\n  var _a;\n\n  (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);\n}\n\nfunction onDefaultRenderSubMenu(subMenuProps, defaultRender) {\n  throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n}\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\n\n\nfunction findItemByKeyFromItems(key, items) {\n  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {\n    var item = items_3[_i];\n\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      var match = findItemByKeyFromItems(key, item.sectionProps.items);\n\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(onClick, target) {\n  return onClick ? function (ev, item) {\n    overrideTarget(ev, target);\n    return onClick(ev, item);\n  } : onClick;\n}\n\nfunction overrideTarget(ev, target) {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["React","ContextualMenuItemType","DirectionalHint","FocusZone","FocusZoneDirection","FocusZoneTabbableElements","divProperties","getNativeProps","shallowCompare","assign","classNamesFunction","css","getFirstFocusable","getLastFocusable","getRTL","KeyCodes","shouldWrapFocus","isIOS","isMac","memoizeFunction","getPropsWithDefaults","getDocument","FocusRects","hasSubmenu","getIsChecked","isItemDisabled","Callout","ContextualMenuItem","ContextualMenuSplitButton","ContextualMenuButton","ContextualMenuAnchor","concatStyleSetsWithProps","getItemStyles","useTarget","usePrevious","useAsync","useWarnings","useId","useIsomorphicLayoutEffect","useResponsiveMode","ResponsiveMode","MenuContext","getClassNames","getContextualMenuItemClassNames","DEFAULT_PROPS","items","shouldFocusOnMount","gapSpace","directionalHint","bottomAutoEdge","beakWidth","getSubmenuItems","item","options","target","subMenuProps","overrideItems","_i","subItem","preferMenuTargetAsEventTarget","contextItem","push","__assign","onClick","getOnClickWithOverrideTarget","canAnyMenuItemsCheck","some","canCheck","sectionProps","NavigationIdleDelay","COMPONENT_NAME","_getMenuItemStylesFunction","styles","styleProps","__spreadArray","useVisibility","props","targetWindow","_a","onMenuDismissed","onMenuOpened","previousHidden","hidden","onMenuOpenedRef","useRef","onMenuClosedRef","propsRef","current","useEffect","_b","useSubMenuState","dismiss","theme","className","id","menuTarget","useState","expandedMenuItemKey","setExpandedMenuItemKey","submenuTarget","setSubmenuTarget","shouldFocusOnContainer","setShouldFocusOnContainer","subMenuId","closeSubMenu","useCallback","undefined","openSubMenu","focusContainer","submenuItemKey","focus","onSubMenuDismiss","useOnSubmenuDismiss","getSubmenuProps","findItemByKeyFromItems","submenuProps","onDismiss","isSubMenu","leftTopEdge","rightTopEdge","isBeakVisible","onItemClick","useShouldUpdateFocusOnMouseMove","delayUpdateFocusOnHover","shouldUpdateFocusOnMouseEvent","gotMouseMove","onMenuFocusCapture","usePreviousActiveElement","onRestoreFocus","previousElementsQueue","tryFocusPreviousActiveElement","documentContainsFocus","targetElement","document","activeElement","targetPosition","indexOf","slice","length","originalElement","containsFocus","hasFocus","useKeyHandlers","hostElement","_c","checkForNoWrap","_d","focusZoneDirection","vertical","lastKeyDownWasAltOrMeta","keyHandler","ev","shouldHandleKey","dismissAllMenus","handled","preventDefault","stopPropagation","shouldCloseSubMenu","submenuCloseKey","right","left","which","shouldHandleKeyDown","escape","up","altKey","metaKey","onKeyDown","isAltOrMeta","shouldHandleKeyUp","keyPressIsAltOrMetaAlone","onKeyUp","onMenuKeyDown","hasModifier","isUp","isDown","down","elementToFocus","lastChild","firstChild","onItemKeyDown","openKey","disabled","enter","currentTarget","useScrollHandler","asyncTracker","isScrollIdle","scrollIdleTimeoutId","onScroll","clearTimeout","setTimeout","isMountedRef","dismissAll","useSubmenuEnterTimer","subMenuHoverDelay","enterTimerRef","cancelSubMenuTimer","startSubmenuTimer","onTimerExpired","useMouseHandlers","subMenuEntryTimer","onItemMouseEnterBase","shouldIgnoreMouseEvent","updateFocusOnMouseEvent","onItemMouseMoveBase","onMouseItemLeave","setActive","e","key","onItemClickBase","executeItemClick","nativeEvent","pointerType","onAnchorClick","isDisabled","overrideTarget","shouldDismiss","defaultPrevented","ContextualMenuBase","memo","forwardRef","propsWithoutDefaults","forwardedRef","ref","menuId","name","deprecations","getMenuClassNames","targetRef","responsiveMode","onDefaultRenderMenuList","menuListProps","menuClassNames","defaultRender","indexCorrection","totalItemCount","hasCheckmarks","hasIcons","list","role","map","index","menuItem","renderMenuItem","itemType","Divider","Header","indexIncrease","customOnRenderListLength","renderFocusZone","children","adjustedFocusZoneProps","ChildrenRenderer","focusableElementIndex","renderedItems","iconProps","iconName","itemProps","dividerClassName","subMenuIconClassName","submenuIconProps","itemClassNames","getItemClassNames","href","primaryDisabled","itemStyleProps","expanded","checked","isAnchorLink","knownIcon","itemClassName","iconClassName","subMenuClassName","subComponentStyles","text","renderSeparator","headerItem","renderHeaderMenuItem","renderListItem","title","Section","renderSectionItem","defaultRenderNormalItem","onRenderContextualMenuItem","Fragment","defaultMenuItemRenderer","sectionItem","groupProps","headerContextualMenuItem","ariaLabelledby","id_1","replace","id_2","topDivider","contextualMenuItem","itemsIndex","bottomDivider","content","classNames","top","fromSection","divider","renderNormalItem","onRender","commonProps","contextualMenuItemAs","onItemMouseEnter","onItemMouseLeave","onItemMouseMove","onItemMouseDown","dismissSubMenu","dismissMenu","split","onTap","divHtmlProperties","header","style","onCheckmarkClick","labelElementId","directionalHintForRTL","alignTargetEdge","coverTarget","ariaLabel","doNotLayer","bounds","useTargetWidth","useTargetAsMinWidth","directionalHintFixed","calloutProps","_k","onRenderSubMenu","onDefaultRenderSubMenu","_l","onRenderMenuList","focusZoneProps","itemsHaveIcons","contextualMenuItems","direction","handleTabKey","all","isCircularNavigation","root","medium","contextMenuStyle","targetAsHtmlElement","offsetWidth","targetBoundingRect","getBoundingClientRect","targetWidth","width","minWidth","totalItemCount_1","itemCount","calloutStyles_1","callout","Consumer","menuContext","setInitialFocus","container","tabIndex","onFocusCapture","prevProps","newProps","shouldUpdateWhenHidden","displayName","alt","onMouseDown","Error","match","persist","Event","Element"],"sources":["/Users/aalyanmahmood/Documents/GitHub/OffCampus-Mac/node_modules/@fluentui/react/lib/components/src/components/ContextualMenu/ContextualMenu.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  Async,\n  assign,\n  classNamesFunction,\n  css,\n  getFirstFocusable,\n  getLastFocusable,\n  getRTL,\n  KeyCodes,\n  shouldWrapFocus,\n  isIOS,\n  isMac,\n  memoizeFunction,\n  getPropsWithDefaults,\n  getDocument,\n  FocusRects,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport {\n  useTarget,\n  usePrevious,\n  useAsync,\n  useWarnings,\n  useId,\n  Target,\n  useIsomorphicLayoutEffect,\n} from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nimport type {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport type { IFocusZoneProps } from '../../FocusZone';\nimport type { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport type { IRenderFunction, IStyleFunctionOrObject } from '../../Utilities';\nimport type { ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport type { IPopupRestoreFocusParams } from '../../Popup';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\n// The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\nconst DEFAULT_PROPS: Partial<IContextualMenuProps> = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16,\n};\n\nexport function getSubmenuItems(\n  item: IContextualMenuItem,\n  options?: {\n    target?: Target;\n  },\n): IContextualMenuItem[] | undefined {\n  const target = options?.target;\n\n  // eslint-disable-next-line deprecation/deprecation\n  const items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    const overrideItems: typeof items = [];\n\n    for (const subItem of items) {\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        const { onClick, ...contextItem } = subItem;\n\n        overrideItems.push({\n          ...contextItem,\n          onClick: getOnClickWithOverrideTarget(onClick, target),\n        });\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250; /* ms */\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n//#region Custom hooks\nfunction useVisibility(props: IContextualMenuProps, targetWindow: Window | undefined) {\n  const { hidden = false, onMenuDismissed, onMenuOpened } = props;\n  const previousHidden = usePrevious(hidden);\n\n  const onMenuOpenedRef = React.useRef(onMenuOpened);\n  const onMenuClosedRef = React.useRef(onMenuDismissed);\n  const propsRef = React.useRef(props);\n\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n\n  React.useEffect(() => {\n    // Don't issue dismissed callbacks on initial mount\n    if (hidden && previousHidden === false) {\n      onMenuClosedRef.current?.(propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      onMenuOpenedRef.current?.(propsRef.current);\n    }\n  }, [hidden, previousHidden]);\n\n  // Issue onDismissedCallback on unmount\n  React.useEffect(() => () => onMenuClosedRef.current?.(propsRef.current), []);\n}\n\nfunction useSubMenuState(\n  { hidden, items, theme, className, id, target: menuTarget }: IContextualMenuProps,\n  dismiss: () => void,\n) {\n  const [expandedMenuItemKey, setExpandedMenuItemKey] = React.useState<string>();\n  const [submenuTarget, setSubmenuTarget] = React.useState<HTMLElement>();\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  const [shouldFocusOnContainer, setShouldFocusOnContainer] = React.useState<boolean>();\n  const subMenuId = useId(COMPONENT_NAME, id);\n\n  const closeSubMenu = React.useCallback(() => {\n    setShouldFocusOnContainer(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n\n  const openSubMenu = React.useCallback(\n    ({ key: submenuItemKey }: IContextualMenuItem, target: HTMLElement, focusContainer?: boolean) => {\n      if (expandedMenuItemKey === submenuItemKey) {\n        return;\n      }\n\n      target.focus();\n\n      setShouldFocusOnContainer(focusContainer);\n      setExpandedMenuItemKey(submenuItemKey);\n      setSubmenuTarget(target);\n    },\n    [expandedMenuItemKey],\n  );\n\n  React.useEffect(() => {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n\n  const onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  const getSubmenuProps = (): IContextualMenuProps | null => {\n    const item = findItemByKeyFromItems(expandedMenuItemKey!, items);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item, { target: menuTarget })!,\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        const { onItemClick } = item;\n\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] as const;\n}\n\nfunction useShouldUpdateFocusOnMouseMove({ delayUpdateFocusOnHover, hidden }: IContextualMenuProps) {\n  const shouldUpdateFocusOnMouseEvent = React.useRef<boolean>(!delayUpdateFocusOnHover);\n  const gotMouseMove = React.useRef<boolean>(false);\n\n  React.useEffect(() => {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n\n  const onMenuFocusCapture = React.useCallback(() => {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = false;\n    }\n  }, [delayUpdateFocusOnHover]);\n\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] as const;\n}\n\nfunction usePreviousActiveElement({ hidden, onRestoreFocus }: IContextualMenuProps, targetWindow: Window | undefined) {\n  const previousElementsQueue = React.useRef<HTMLElement[]>([]);\n\n  const tryFocusPreviousActiveElement = React.useCallback(\n    (options: IPopupRestoreFocusParams) => {\n      if (onRestoreFocus) {\n        onRestoreFocus(options);\n      } else if (options?.documentContainsFocus) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n\n        previousElementsQueue.current[0]?.focus?.();\n      }\n    },\n    [onRestoreFocus],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!hidden) {\n      const targetElement = targetWindow?.document.activeElement as HTMLElement;\n      const targetPosition = previousElementsQueue.current.indexOf(targetElement);\n\n      if (targetPosition > -1) {\n        previousElementsQueue.current = previousElementsQueue.current.slice(targetPosition + 1);\n      } else {\n        previousElementsQueue.current = [targetElement, ...previousElementsQueue.current];\n      }\n    } else if (previousElementsQueue.current.length > 0) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousElementsQueue.current[0],\n        containsFocus: true,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      previousElementsQueue.current = [];\n    }\n  }, [hidden, targetWindow?.document.activeElement, tryFocusPreviousActiveElement]);\n\n  return [tryFocusPreviousActiveElement] as const;\n}\n\nfunction useKeyHandlers(\n  {\n    theme,\n    isSubMenu,\n    focusZoneProps: { checkForNoWrap, direction: focusZoneDirection = FocusZoneDirection.vertical } = {},\n  }: IContextualMenuProps,\n  dismiss: (ev?: any, dismissAll?: boolean | undefined) => void | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement) => void,\n) {\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  const lastKeyDownWasAltOrMeta = React.useRef<boolean | undefined>();\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  const keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  const shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(\n      focusZoneDirection === FocusZoneDirection.vertical ||\n      (checkForNoWrap && !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  const shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape ||\n      shouldCloseSubMenu(ev) ||\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  const onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  const shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  const onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return keyHandler(ev, shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  const onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    // eslint-disable-next-line deprecation/deprecation\n    const isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(hostElement.current, hostElement.current.lastChild as HTMLElement, true)\n        : getFirstFocusable(hostElement.current, hostElement.current.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  const onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      openSubMenu(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] as const;\n}\n\nfunction useScrollHandler(asyncTracker: Async) {\n  const isScrollIdle = React.useRef<boolean>(true);\n  const scrollIdleTimeoutId = React.useRef<number | undefined>();\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  const onScroll = (): void => {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(() => {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle] as const;\n}\n\nfunction useOnSubmenuDismiss(dismiss: (ev?: any, dismissAll?: boolean) => void, closeSubMenu: () => void) {\n  const isMountedRef = React.useRef(false);\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  const onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer({ subMenuHoverDelay = NavigationIdleDelay }: IContextualMenuProps, asyncTracker: Async) {\n  const enterTimerRef = React.useRef<number | undefined>(undefined);\n\n  const cancelSubMenuTimer = () => {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  const startSubmenuTimer = (onTimerExpired: () => void) => {\n    enterTimerRef.current = asyncTracker.setTimeout(() => {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef as React.RefObject<number | undefined>] as const;\n}\n\nfunction useMouseHandlers(\n  props: IContextualMenuProps,\n  isScrollIdle: React.MutableRefObject<boolean>,\n  subMenuEntryTimer: React.RefObject<number | undefined>,\n  targetWindow: Window | undefined,\n  shouldUpdateFocusOnMouseEvent: React.MutableRefObject<boolean>,\n  gotMouseMove: React.MutableRefObject<boolean>,\n  expandedMenuItemKey: string | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  startSubmenuTimer: (onTimerExpired: () => void) => void,\n  cancelSubMenuTimer: () => void,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement, openedByMouseClick?: boolean) => void,\n  onSubMenuDismiss: (ev?: any, dismissAll?: boolean) => void,\n  dismiss: (ev?: any, dismissAll?: boolean) => void,\n) {\n  const { target: menuTarget } = props;\n\n  const onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    }\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (\n      !isScrollIdle.current ||\n      subMenuEntryTimer.current !== undefined ||\n      targetElement === (targetWindow?.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const shouldIgnoreMouseEvent = (): boolean => {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  const onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((hostElement.current as any).setActive) {\n      try {\n        (hostElement.current as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      hostElement.current?.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  const updateFocusOnMouseEvent = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement>,\n    target?: HTMLElement,\n  ) => {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    // If the menu is not expanded we can update focus without any delay\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(() => {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(() => {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  const onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  const onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item, { target: menuTarget });\n\n    // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n\n        // focus on the container by default when the menu is opened with a click event\n        // this differentiates from a keyboard interaction triggering the click event\n        const shouldFocusOnContainer =\n          typeof props.shouldFocusOnContainer === 'boolean'\n            ? props.shouldFocusOnContainer\n            : (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n        openSubMenu(item, target, shouldFocusOnContainer);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  const onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  const executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    let shouldDismiss = false;\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [\n    onItemMouseEnterBase,\n    onItemMouseMoveBase,\n    onMouseItemLeave,\n    onItemClick,\n    onAnchorClick,\n    executeItemClick,\n    onItemClickBase,\n  ] as const;\n}\n//#endregion\n\nexport const ContextualMenuBase: React.FunctionComponent<IContextualMenuProps> = React.memo(\n  React.forwardRef<HTMLDivElement, IContextualMenuProps>((propsWithoutDefaults, forwardedRef) => {\n    const { ref, ...props } = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const asyncTracker = useAsync();\n    const menuId = useId(COMPONENT_NAME, props.id);\n\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: {\n        getMenuClassNames: 'styles',\n      },\n    });\n\n    const dismiss = (ev?: any, dismissAll?: boolean) => props.onDismiss?.(ev, dismissAll);\n    const [targetRef, targetWindow] = useTarget(props.target, hostElement);\n    const [tryFocusPreviousActiveElement] = usePreviousActiveElement(props, targetWindow);\n    const [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] = useSubMenuState(props, dismiss);\n    const [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] = useShouldUpdateFocusOnMouseMove(props);\n    const [onScroll, isScrollIdle] = useScrollHandler(asyncTracker);\n    const [cancelSubMenuTimer, startSubmenuTimer, subMenuEntryTimer] = useSubmenuEnterTimer(props, asyncTracker);\n\n    const responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n\n    useVisibility(props, targetWindow);\n\n    const [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] = useKeyHandlers(props, dismiss, hostElement, openSubMenu);\n    const [\n      onItemMouseEnterBase,\n      onItemMouseMoveBase,\n      onMouseItemLeave,\n      onItemClick,\n      onAnchorClick,\n      executeItemClick,\n      onItemClickBase,\n    ] = useMouseHandlers(\n      props,\n      isScrollIdle,\n      subMenuEntryTimer,\n      targetWindow,\n      shouldUpdateFocusOnMouseEvent,\n      gotMouseMove,\n      expandedMenuItemKey,\n      hostElement,\n      startSubmenuTimer,\n      cancelSubMenuTimer,\n      openSubMenu,\n      onSubMenuDismiss,\n      dismiss,\n    );\n\n    //#region Render helpers\n\n    const onDefaultRenderMenuList = (\n      menuListProps: IContextualMenuListProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      defaultRender?: IRenderFunction<IContextualMenuListProps>,\n    ): JSX.Element => {\n      let indexCorrection = 0;\n      const { items, totalItemCount, hasCheckmarks, hasIcons } = menuListProps;\n\n      return (\n        <ul className={menuClassNames.list} onKeyDown={onKeyDown} onKeyUp={onKeyUp} role={'presentation'}>\n          {items.map((item, index) => {\n            const menuItem = renderMenuItem(\n              item,\n              index,\n              indexCorrection,\n              totalItemCount,\n              hasCheckmarks,\n              hasIcons,\n              menuClassNames,\n            );\n            if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n              const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n              indexCorrection += indexIncrease;\n            }\n            return menuItem;\n          })}\n        </ul>\n      );\n    };\n\n    const renderFocusZone = (children: JSX.Element | null, adjustedFocusZoneProps: IFocusZoneProps): JSX.Element => {\n      const { focusZoneAs: ChildrenRenderer = FocusZone } = props;\n      return <ChildrenRenderer {...adjustedFocusZoneProps}>{children}</ChildrenRenderer>;\n    };\n\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n    const renderMenuItem = (\n      item: IContextualMenuItem,\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): JSX.Element => {\n      const renderedItems: React.ReactNode[] = [];\n      const iconProps = item.iconProps || { iconName: 'None' };\n      const {\n        getItemClassNames, // eslint-disable-line deprecation/deprecation\n        itemProps,\n      } = item;\n      const styles = itemProps ? itemProps.styles : undefined;\n\n      // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n      const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n      // eslint-disable-next-line deprecation/deprecation\n      let itemClassNames: IMenuItemClassNames;\n\n      // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(\n          props.theme!,\n          isItemDisabled(item),\n          expandedMenuItemKey === item.key,\n          !!getIsChecked(item),\n          !!item.href,\n          iconProps.iconName !== 'None',\n          item.className,\n          dividerClassName,\n          iconProps.className,\n          subMenuIconClassName,\n          item.primaryDisabled,\n        );\n      } else {\n        const itemStyleProps: IContextualMenuItemStyleProps = {\n          theme: props.theme!,\n          disabled: isItemDisabled(item),\n          expanded: expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled,\n        };\n\n        // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n        itemClassNames = getContextualMenuItemClassNames(\n          _getMenuItemStylesFunction(menuClassNames.subComponentStyles?.menuItem, styles),\n          itemStyleProps,\n        );\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          break;\n        case ContextualMenuItemType.Header:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          const headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n          renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n        case ContextualMenuItemType.Section:\n          renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n          break;\n        default:\n          const defaultRenderNormalItem = () =>\n            renderNormalItem(\n              item,\n              itemClassNames,\n              index,\n              focusableElementIndex,\n              totalItemCount,\n              hasCheckmarks,\n              hasIcons,\n            ) as JSX.Element;\n\n          const menuItem = props.onRenderContextualMenuItem\n            ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem)\n            : defaultRenderNormalItem();\n          renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      }\n\n      // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n      return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n    };\n\n    const defaultMenuItemRenderer = (\n      item: IContextualMenuItemRenderProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): React.ReactNode => {\n      const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n      return renderMenuItem(\n        item,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        menuClassNames,\n      );\n    };\n\n    const renderSectionItem = (\n      sectionItem: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ) => {\n      const sectionProps = sectionItem.sectionProps;\n      if (!sectionProps) {\n        return;\n      }\n\n      let headerItem;\n      let groupProps;\n      if (sectionProps.title) {\n        let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n        let ariaLabelledby = '';\n        if (typeof sectionProps.title === 'string') {\n          // Since title is a user-facing string, it needs to be stripped\n          // of whitespace in order to build a valid element ID\n          const id = menuId + sectionProps.title.replace(/\\s/g, '');\n          headerContextualMenuItem = {\n            key: `section-${sectionProps.title}-title`,\n            itemType: ContextualMenuItemType.Header,\n            text: sectionProps.title,\n            id: id,\n          };\n          ariaLabelledby = id;\n        } else {\n          const id = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n          headerContextualMenuItem = { ...sectionProps.title, id };\n          ariaLabelledby = id;\n        }\n\n        if (headerContextualMenuItem) {\n          groupProps = {\n            role: 'group',\n            'aria-labelledby': ariaLabelledby,\n          };\n          headerItem = renderHeaderMenuItem(\n            headerContextualMenuItem,\n            itemClassNames,\n            menuClassNames,\n            index,\n            hasCheckmarks,\n            hasIcons,\n          );\n        }\n      }\n\n      if (sectionProps.items && sectionProps.items.length > 0) {\n        return (\n          <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n            <div {...groupProps}>\n              <ul className={menuClassNames.list} role=\"presentation\">\n                {sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true)}\n                {headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title)}\n                {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                  renderMenuItem(\n                    contextualMenuItem,\n                    itemsIndex,\n                    itemsIndex,\n                    sectionProps.items.length,\n                    hasCheckmarks,\n                    hasIcons,\n                    menuClassNames,\n                  ),\n                )}\n                {sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)}\n              </ul>\n            </div>\n          </li>\n        );\n      }\n    };\n\n    const renderListItem = (\n      content: React.ReactNode,\n      key: string | number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      title?: string,\n    ) => {\n      return (\n        <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n          {content}\n        </li>\n      );\n    };\n\n    const renderSeparator = (\n      index: number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      top?: boolean,\n      fromSection?: boolean,\n    ): React.ReactNode => {\n      if (fromSection || index > 0) {\n        return (\n          <li\n            role=\"separator\"\n            key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n            className={classNames.divider}\n            aria-hidden=\"true\"\n          />\n        );\n      }\n      return null;\n    };\n\n    const renderNormalItem = (\n      item: IContextualMenuItem,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      if (item.onRender) {\n        return item.onRender(\n          { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n          dismiss,\n        );\n      }\n\n      const { contextualMenuItemAs } = props;\n\n      const commonProps = {\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        contextualMenuItemAs,\n        onItemMouseEnter: onItemMouseEnterBase,\n        onItemMouseLeave: onMouseItemLeave,\n        onItemMouseMove: onItemMouseMoveBase,\n        onItemMouseDown: onItemMouseDown,\n        executeItemClick: executeItemClick,\n        onItemKeyDown: onItemKeyDown,\n        expandedMenuItemKey,\n        openSubMenu,\n        dismissSubMenu: onSubMenuDismiss,\n        dismissMenu: dismiss,\n      } as const;\n\n      if (item.href) {\n        return <ContextualMenuAnchor {...commonProps} onItemClick={onAnchorClick} />;\n      }\n\n      if (item.split && hasSubmenu(item)) {\n        return (\n          <ContextualMenuSplitButton\n            {...commonProps}\n            onItemClick={onItemClick}\n            onItemClickBase={onItemClickBase}\n            onTap={cancelSubMenuTimer}\n          />\n        );\n      }\n\n      return <ContextualMenuButton {...commonProps} onItemClick={onItemClick} onItemClickBase={onItemClickBase} />;\n    };\n\n    const renderHeaderMenuItem = (\n      item: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = props;\n      const { itemProps, id } = item;\n      const divHtmlProperties =\n        itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n      return (\n        // eslint-disable-next-line deprecation/deprecation\n        <div id={id} className={menuClassNames.header} {...divHtmlProperties} style={item.style}>\n          <ChildrenRenderer\n            item={item}\n            classNames={itemClassNames}\n            index={index}\n            onCheckmarkClick={hasCheckmarks ? onItemClick : undefined}\n            hasIcons={hasIcons}\n            {...itemProps}\n          />\n        </div>\n      );\n    };\n    //#endregion\n\n    //#region Main render\n    let { isBeakVisible } = props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = onDefaultRenderSubMenu,\n      onRenderMenuList = (\n        menuListProps: IContextualMenuListProps,\n        defaultRender?: IRenderFunction<IContextualMenuListProps>,\n      ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = props;\n\n    const classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const adjustedFocusZoneProps = {\n      direction: FocusZoneDirection.vertical,\n      handleTabKey: FocusZoneTabbableElements.all,\n      isCircularNavigation: true,\n      ...focusZoneProps,\n      className: css(classNames.root, props.focusZoneProps?.className),\n    };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle: React.CSSProperties;\n    const targetAsHtmlElement = targetRef.current as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = classNames.subComponentStyles\n        ? (classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <MenuContext.Consumer>\n          {menuContext => (\n            <Callout\n              styles={calloutStyles}\n              onRestoreFocus={tryFocusPreviousActiveElement}\n              {...calloutProps}\n              target={target || (menuContext.target as IContextualMenuProps['target'])}\n              isBeakVisible={isBeakVisible}\n              beakWidth={beakWidth}\n              directionalHint={directionalHint}\n              directionalHintForRTL={directionalHintForRTL}\n              gapSpace={gapSpace}\n              coverTarget={coverTarget}\n              doNotLayer={doNotLayer}\n              className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n              setInitialFocus={shouldFocusOnMount}\n              onDismiss={props.onDismiss || menuContext.onDismiss}\n              onScroll={onScroll}\n              bounds={bounds}\n              directionalHintFixed={directionalHintFixed}\n              alignTargetEdge={alignTargetEdge}\n              hidden={props.hidden || menuContext.hidden}\n              ref={forwardedRef}\n            >\n              <div\n                style={contextMenuStyle}\n                ref={hostElement}\n                id={id}\n                className={classNames.container}\n                tabIndex={shouldFocusOnContainer ? 0 : -1}\n                onKeyDown={onMenuKeyDown}\n                onKeyUp={onKeyUp}\n                onFocusCapture={onMenuFocusCapture}\n                aria-label={ariaLabel}\n                aria-labelledby={labelElementId}\n                role={'menu'}\n              >\n                {title && <div className={classNames.title}> {title} </div>}\n                {items && items.length\n                  ? renderFocusZone(\n                      onRenderMenuList(\n                        {\n                          ariaLabel,\n                          items,\n                          totalItemCount,\n                          hasCheckmarks,\n                          hasIcons,\n                          defaultMenuItemRenderer: (item: IContextualMenuItemRenderProps) =>\n                            defaultMenuItemRenderer(item, classNames),\n                          labelElementId,\n                        },\n                        (\n                          menuListProps: IContextualMenuListProps,\n                          defaultRender?: IRenderFunction<IContextualMenuListProps>,\n                        ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n                      ),\n                      adjustedFocusZoneProps,\n                    )\n                  : null}\n                {submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)}\n              </div>\n              <FocusRects />\n            </Callout>\n          )}\n        </MenuContext.Consumer>\n      );\n    } else {\n      return null;\n    }\n    //#endregion\n  }),\n  (prevProps, newProps) => {\n    if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n\n    return shallowCompare(prevProps, newProps);\n  },\n);\nContextualMenuBase.displayName = 'ContextualMenuBase';\n\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void {\n  item.onMouseDown?.(item, ev);\n}\n\nfunction onDefaultRenderSubMenu(\n  subMenuProps: IContextualMenuProps,\n  defaultRender?: IRenderFunction<IContextualMenuProps>,\n): JSX.Element {\n  throw Error(\n    'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n      'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n  );\n}\n\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\nfunction findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n  for (const item of items) {\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      const match = findItemByKeyFromItems(key, item.sectionProps.items);\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(\n  onClick:\n    | ((\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => boolean | void)\n    | undefined,\n  target: Target | undefined,\n) {\n  return onClick\n    ? (\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => {\n        overrideTarget(ev, target);\n\n        return onClick(ev, item);\n      }\n    : onClick;\n}\n\nfunction overrideTarget(\n  ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n  target?: Target,\n): void {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target as HTMLElement;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}